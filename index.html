<!DOCTYPE html>
<html>
  <head>
    <title>Nozzle Contour Generator</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
      .meta-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 6px 0 10px 0; /* small breathing room */
      }

      .byline {
        margin: 0; /* keep the row tight */
      }

      .theme-toggle {
        border: 1px solid var(--border);
        background: var(--panel);
        color: var(--text);
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
      }

      body {
        font-family: sans-serif;
        margin: 20px;
        display: flex;
        flex-direction: row;
        gap: 40px;
      }
      #controls {
        display: flex;
        flex-direction: column;
        width: 320px;
      }

      /* --- Make STL panel match the controls look --- */
      #stlPanel {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: stretch;
      }

      #stlPanel label {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        color: var(--text);
      }

      #stlPanel .input-row {
        display: flex;
        gap: 5px;
        align-items: center;
      }

      #stlPanel .input-row input[type="number"] {
        background: var(--input);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 6px 8px;
        width: 120px;
      }

      /* Button same style as the CSV button */
      #stlPanel button {
        background: var(--accent);
        color: #001018;
        border: 0;
        border-radius: 10px;
        padding: 10px 12px;
        cursor: pointer;
      }

      label {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
      }
      .input-row {
        display: flex;
        gap: 5px;
        align-items: center;
      }
      input[type="range"] {
        flex: 1;
      }
      input[type="number"] {
        width: 70px;
      }
      #outputs {
        margin-top: 20px;
        font-size: 14px;
      }
      h1 {
        margin-bottom: 0;
      }
      h2 {
        margin-top: 40px;
        margin-bottom: 10px;
      }
    </style>

    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />

    <style>
      /* THEME TOKENS */
      :root {
        --bg: #0b0f19; /* dark default */
        --panel: #111827;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --accent: #22d3ee;
        --input: #1f2937;
        --border: #334155;
        --link: #38bdf8;
        --font: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial,
          sans-serif;
      }
      [data-theme="light"] {
        --bg: #ffffff;
        --panel: #f8fafc;
        --text: #0f172a;
        --muted: #475569;
        --accent: #0ea5e9;
        --input: #ffffff;
        --border: #e2e8f0;
        --link: #0284c7;
      }

      /* APPLY TOKENS */
      body {
        background: var(--bg);
        color: var(--text);
        font-family: var(--font);
      }
      #controls label {
        color: var(--text);
      }
      #controls .input-row input[type="number"],
      #controls .input-row input[type="range"],
      #controls select {
        background: var(--input);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 6px 8px;
      }
      #controls button {
        background: var(--accent);
        color: #001018;
        border: 0;
        border-radius: 10px;
        padding: 10px 12px;
        margin-top: 14px;
        cursor: pointer;
      }
      a {
        color: var(--link);
      }
      #vizRow {
        background: transparent;
      }
    </style>
  </head>
  <body data-theme="light">
    <div>
      <h1 style="display: flex; align-items: center; gap: 12px">
        Nozzle Contour Generator
      </h1>
      <div class="meta-row">
        <p class="byline"><em>By Saaketh Ramoju</em></p>
        <button id="themeToggle" class="theme-toggle">Light mode</button>
      </div>

      <div id="controls">
        <label
          >Nozzle Shape:
          <select id="b_or_c" onchange="updatePlot()">
            <option value="Conical">Conical</option>
            <option value="Bell">Bell</option>
          </select>
        </label>

        <!-- Example with slider + number input -->
        <label
          >Throat Radius (in):
          <div class="input-row">
            <input
              id="R_t"
              type="range"
              min="0.1"
              max="15"
              step="0.001"
              value="1"
              oninput="syncInput('R_t')"
            />
            <input
              id="R_t_num"
              type="number"
              min="0.1"
              max="15"
              step="0.001"
              value="1"
              oninput="syncSlider('R_t')"
            />
          </div>
        </label>

        <label
          >Chamber Cylindrical Length (in):
          <div class="input-row">
            <input
              id="Lc"
              type="range"
              min="1"
              max="100"
              step="0.001"
              value="10"
              oninput="syncInput('Lc')"
            />
            <input
              id="Lc_num"
              type="number"
              min="1"
              max="100"
              step="0.001"
              value="10"
              oninput="syncSlider('Lc')"
            />
          </div>
        </label>

        <label
          >Contraction Ratio:
          <div class="input-row">
            <input
              id="eps_c"
              type="range"
              min="1.5"
              max="5"
              step="0.001"
              value="3.8"
              oninput="syncInput('eps_c')"
            />
            <input
              id="eps_c_num"
              type="number"
              min="1.5"
              max="5"
              step="0.001"
              value="3.8"
              oninput="syncSlider('eps_c')"
            />
          </div>
        </label>

        <label
          >Convergence Half-Angle (°):
          <div class="input-row">
            <input
              id="theta_c"
              type="range"
              min="10"
              max="50"
              step="0.001"
              value="37.5"
              oninput="syncInput('theta_c')"
            />
            <input
              id="theta_c_num"
              type="number"
              min="10"
              max="50"
              step="0.001"
              value="37.5"
              oninput="syncSlider('theta_c')"
            />
          </div>
        </label>

        <label
          >Convergence Radius Rc/Rt:
          <div class="input-row">
            <input
              id="Rc_Rt"
              type="range"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncInput('Rc_Rt')"
            />
            <input
              id="Rc_Rt_num"
              type="number"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncSlider('Rc_Rt')"
            />
          </div>
        </label>

        <label
          >Lead-in Radius Rtc/Rt:
          <div class="input-row">
            <input
              id="Rtc_Rt"
              type="range"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncInput('Rtc_Rt')"
            />
            <input
              id="Rtc_Rt_num"
              type="number"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncSlider('Rtc_Rt')"
            />
          </div>
        </label>

        <label
          >Lead-out Radius Rtd/Rt:
          <div class="input-row">
            <input
              id="Rtd_Rt"
              type="range"
              min="0.1"
              max="4"
              step="0.001"
              value="0.5"
              oninput="syncInput('Rtd_Rt')"
            />
            <input
              id="Rtd_Rt_num"
              type="number"
              min="0.1"
              max="4"
              step="0.001"
              value="0.5"
              oninput="syncSlider('Rtd_Rt')"
            />
          </div>
        </label>

        <label
          >Expansion Ratio:
          <div class="input-row">
            <input
              id="eps"
              type="range"
              min="2"
              max="100"
              step="0.001"
              value="4"
              oninput="syncInput('eps')"
            />
            <input
              id="eps_num"
              type="number"
              min="2"
              max="100"
              step="0.001"
              value="4"
              oninput="syncSlider('eps')"
            />
          </div>
        </label>

        <label
          >Divergence Half-Angle (°) [Conical]:
          <div class="input-row">
            <input
              id="alpha"
              type="range"
              min="5"
              max="60"
              step="0.001"
              value="15"
              oninput="syncInput('alpha')"
            />
            <input
              id="alpha_num"
              type="number"
              min="5"
              max="60"
              step="0.001"
              value="15"
              oninput="syncSlider('alpha')"
            />
          </div>
        </label>

        <label
          >Divergence Entrance Angle (°) [Bell]:
          <div class="input-row">
            <input
              id="theta_n"
              type="range"
              min="10"
              max="80"
              step="0.001"
              value="22"
              oninput="syncInput('theta_n')"
            />
            <input
              id="theta_n_num"
              type="number"
              min="10"
              max="80"
              step="0.001"
              value="22"
              oninput="syncSlider('theta_n')"
            />
          </div>
        </label>

        <label
          >Divergence Exit Angle (°) [Bell]:
          <div class="input-row">
            <input
              id="theta_e"
              type="range"
              min="0"
              max="50"
              step="0.001"
              value="10"
              oninput="syncInput('theta_e')"
            />
            <input
              id="theta_e_num"
              type="number"
              min="0"
              max="50"
              step="0.001"
              value="10"
              oninput="syncSlider('theta_e')"
            />
          </div>
        </label>

        <label
          >Percent Bell Lf (%):
          <div class="input-row">
            <input
              id="Lf"
              type="range"
              min="60"
              max="100"
              step="0.001"
              value="80"
              oninput="syncInput('Lf')"
            />
            <input
              id="Lf_num"
              type="number"
              min="60"
              max="100"
              step="0.001"
              value="80"
              oninput="syncSlider('Lf')"
            />
          </div>
        </label>

        <button onclick="downloadCSV()">Download Contour CSV</button>
      </div>
    </div>

    <div style="flex: 1; min-width: 0">
      <div
        id="vizRow"
        style="
          display: flex;
          flex-direction: row;
          gap: 16px;
          align-items: flex-start;
          width: 100%;
        "
      >
        <!-- leave ~420px for the controls column -->
        <div id="plot" style="flex: 1; min-width: 0; height: 520px"></div>
        <!-- 3D column: plot on top, STL panel underneath -->
        <div
          id="plot3dCol"
          style="
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
          "
        >
          <div id="plot3d" style="height: 520px"></div>
          <!-- STL panel directly under 3D plot -->
          <div id="stlPanel">
            <label>
              Wall Thickness (in):
              <div class="input-row">
                <input
                  id="wall_t_val"
                  type="number"
                  min="0"
                  step="0.001"
                  value="0.100"
                />
              </div>
            </label>

            <button onclick="downloadSTL()">Download STL</button>
          </div>
        </div>
      </div>
      <h2>Calculated Values</h2>
      <div id="outputs"></div>
    </div>

    <script>
      // THEME HELPERS
      function setTheme(t) {
        document.body.setAttribute("data-theme", t);
        localStorage.setItem("nozzle_theme", t);
        const btn = document.getElementById("themeToggle");
        if (btn) btn.textContent = t === "dark" ? "Light mode" : "Dark mode";
      }
      function getTheme() {
        return document.body.getAttribute("data-theme") || "dark";
      }
      // init theme on load
      (function initTheme() {
        const saved = localStorage.getItem("nozzle_theme");
        if (saved === "light" || saved === "dark") {
          document.body.setAttribute("data-theme", saved);
        } else {
          document.body.setAttribute("data-theme", "light"); // default to light
        }
        window.addEventListener("DOMContentLoaded", () => {
          const btn = document.getElementById("themeToggle");
          if (btn) {
            btn.addEventListener("click", () => {
              setTheme(getTheme() === "dark" ? "light" : "dark");
              updatePlot(); // re-render plots with new template/colors
            });
            // reflect initial label
            btn.textContent =
              getTheme() === "dark" ? "Light mode" : "Dark mode";
          }
        });
      })();

      // keep number and slider in sync
      function syncInput(id) {
        document.getElementById(id + "_num").value =
          document.getElementById(id).value;
        updatePlot();
      }
      function syncSlider(id) {
        document.getElementById(id).value = document.getElementById(
          id + "_num"
        ).value;
        updatePlot();
      }

      function getVal(id) {
        return parseFloat(document.getElementById(id).value);
      }

      function linspace(start, stop, n) {
        return Array.from(
          { length: n },
          (_, i) => start + ((stop - start) * i) / (n - 1)
        );
      }

      function updatePlot() {
        let b_or_c = document.getElementById("b_or_c").value;
        let R_t = getVal("R_t");
        let Lc = getVal("Lc");
        let eps_c = getVal("eps_c");
        let theta_c = (getVal("theta_c") * Math.PI) / 180;
        let Rc = getVal("Rc_Rt") * R_t;
        let Rtc = getVal("Rtc_Rt") * R_t;
        let Rtd = getVal("Rtd_Rt") * R_t;
        let eps = getVal("eps");
        let alpha = (getVal("alpha") * Math.PI) / 180;
        let theta_n = (getVal("theta_n") * Math.PI) / 180;
        let theta_e = (getVal("theta_e") * Math.PI) / 180;
        let Lf = getVal("Lf");

        // --- Geometry sections (same as before) ---
        let f1z = linspace(0, Lc, 200);
        let f1r = f1z.map(() => Math.sqrt(eps_c) * R_t);
        let t2 = linspace(Math.PI / 2, Math.PI / 2 - theta_c, 200);
        let f2z = t2.map((tt) => Rc * Math.cos(tt) + Lc);
        let f2r = t2.map(
          (tt) => Rc * Math.sin(tt) + Math.sqrt(eps_c) * R_t - Rc
        );
        let y3 =
          R_t * (Math.sqrt(eps_c) - 1) -
          (Rc - Rc * Math.cos(theta_c)) -
          (Rtc - Rtc * Math.cos(theta_c));
        let x3 = y3 / Math.tan(theta_c);
        let f3z = linspace(f2z[f2z.length - 1], f2z[f2z.length - 1] + x3, 200);
        let m3 = -Math.tan(theta_c);
        let f3r = f3z.map(
          (z) => m3 * (z - f2z[f2z.length - 1]) + f2r[f2r.length - 1]
        );
        let h = f3z[f3z.length - 1] + Rtc * Math.sin(theta_c);
        let k = R_t + Rtc;
        let t4 = linspace(
          Math.PI + Math.PI / 2 - theta_c,
          (3 * Math.PI) / 2,
          200
        );
        let f4z = t4.map((tt) => Rtc * Math.cos(tt) + h);
        let f4r = t4.map((tt) => Rtc * Math.sin(tt) + k);

        const zThroat = f4z[f4z.length - 1];

        let f5z, f5r;
        if (b_or_c == "Conical") {
          let t5 = linspace((3 * Math.PI) / 2, (3 * Math.PI) / 2 + alpha, 200);
          f5z = t5.map((tt) => Rtd * Math.cos(tt) + h);
          f5r = t5.map((tt) => Rtd * Math.sin(tt) + R_t + Rtd);
        } else {
          let t5 = linspace(
            (3 * Math.PI) / 2,
            (3 * Math.PI) / 2 + theta_n,
            200
          );
          f5z = t5.map((tt) => Rtd * Math.cos(tt) + h);
          f5r = t5.map((tt) => Rtd * Math.sin(tt) + R_t + Rtd);
        }

        let f6z, f6r;
        if (b_or_c == "Conical") {
          let length =
            (Math.sqrt(eps) * R_t - f5r[f5r.length - 1]) / Math.tan(alpha);
          f6z = linspace(
            f5z[f5z.length - 1],
            f5z[f5z.length - 1] + length,
            200
          );
          let m6 = Math.tan(alpha);
          f6r = f6z.map(
            (z) => m6 * (z - f5z[f5z.length - 1]) + f5r[f5r.length - 1]
          );
        } else {
          let N = [f5z[f5z.length - 1], f5r[f5r.length - 1]];
          let E = [
            (Lf / 100) *
              ((Math.sqrt(eps) * R_t - f5r[f5r.length - 1]) /
                Math.tan((15 * Math.PI) / 180)) +
              f4z[f4z.length - 1],
            Math.sqrt(eps) * R_t,
          ];
          let m1 = Math.tan(theta_n),
            m2 = Math.tan(theta_e);
          let Qx = (m1 * N[0] - N[1] - m2 * E[0] + E[1]) / (m1 - m2);
          let Qy = m1 * (Qx - N[0]) + N[1];
          let t = linspace(0, 1, 200);
          f6z = t.map(
            (tt) =>
              (1 - tt) ** 2 * N[0] + 2 * (1 - tt) * tt * Qx + tt ** 2 * E[0]
          );
          f6r = t.map(
            (tt) =>
              (1 - tt) ** 2 * N[1] + 2 * (1 - tt) * tt * Qy + tt ** 2 * E[1]
          );
        }

        let z = [].concat(
          f1z,
          f2z.slice(1),
          f3z.slice(1),
          f4z.slice(1),
          f5z.slice(1),
          f6z.slice(1)
        );
        let r = [].concat(
          f1r,
          f2r.slice(1),
          f3r.slice(1),
          f4r.slice(1),
          f5r.slice(1),
          f6r.slice(1)
        );
        window.currentContour = { z, r, zThroat };

        // ==== THEME VARS FOR PLOTS ====
        const theme = getTheme();

        const template = theme === "dark" ? "plotly_dark" : "plotly_white";
        const paperBG =
          getComputedStyle(document.body).getPropertyValue("--bg").trim() ||
          (theme === "dark" ? "#0b0f19" : "#ffffff");
        const plotBG = paperBG; // match paper

        // ==== HIGH-CONTRAST PLOT COLORS (dark mode) ====
        const isDark = getTheme() === "dark";
        const axisColor = isDark ? "#cbd5e1" : undefined; // light slate
        const gridColor = isDark ? "#334155" : undefined; // slate-700
        const zeroColor = isDark ? "#475569" : undefined; // slate-600
        const lineColor = isDark ? "#94a3b8" : undefined; // slate-400
        const fontFamily =
          getComputedStyle(document.body).getPropertyValue("--font").trim() ||
          "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
        const baseFont = { family: fontFamily, size: 13, color: axisColor };

        // ---- shared extents (unique names so they won't collide) ----
        const zMinAll = Math.min(...z);
        const zMaxAll = Math.max(...z);
        const rMaxAll = Math.max(...r);

        // ===== 3D solid-of-revolution (throat-centered, y-axis orbit) =====
        const nTheta = 72;
        const theta = linspace(0, 2 * Math.PI, nTheta);
        const X = theta.map((th) => r.map((ri) => ri * Math.cos(th)));
        const Y = theta.map((th) => r.map((ri) => ri * Math.sin(th)));
        const Zgrid = theta.map(() => z.map((zi) => zi - zThroat));
        const Rgrid = theta.map(() => r.slice()); // same shape as X/Y/Z

        // ----- radius-dominant scalar with gentle axial tint on flat sections -----
        const rMin = Math.min(...r),
          rMax = Math.max(...r);
        const rNorm = r.map((v) => (v - rMin) / Math.max(1e-9, rMax - rMin));

        // Nonlinear remap to boost mid-range contrast
        const gamma = 0.7; // 0.55–0.85 is a good tuning range
        const rEq = rNorm.map((t) => Math.pow(t, gamma));

        // Local slope |dr/dz| to detect flat regions (≈ chamber)
        const rSlope = r.map((_, i) => {
          if (i === 0)
            return Math.abs((r[1] - r[0]) / Math.max(1e-9, z[1] - z[0]));
          if (i === r.length - 1)
            return Math.abs(
              (r[i] - r[i - 1]) / Math.max(1e-9, z[i] - z[i - 1])
            );
          const s1 = (r[i] - r[i - 1]) / Math.max(1e-9, z[i] - z[i - 1]);
          const s2 = (r[i + 1] - r[i]) / Math.max(1e-9, z[i + 1] - z[i]);
          return Math.abs(0.5 * (s1 + s2));
        });

        // Weight: 1 on very flat regions, 0 on sloped ones (smoothly)
        const SLOPE_FLAT = 1e-3; // slope threshold where we start treating as "flat"
        const SLOPE_STEEP = 5e-3; // slope considered definitely "not flat"
        function smoothstep(edge0, edge1, x) {
          const t = Math.min(
            1,
            Math.max(0, (x - edge0) / Math.max(1e-9, edge1 - edge0))
          );
          return t * t * (3 - 2 * t);
        }
        const wFlat = rSlope.map(
          (s) => 1 - smoothstep(SLOPE_FLAT, SLOPE_STEEP, s)
        ); // ~1 in chamber

        // Gentle axial gradient only where flat
        const zMin = Math.min(...z),
          zMax = Math.max(...z);
        const zNorm = z.map((zz) => (zz - zMin) / Math.max(1e-9, zMax - zMin));

        // Blend: keep radius as the base, add a small z tint on flat areas
        const AXIAL_AMOUNT = 0.25; // max added influence of z in flat sections (0.15–0.35)
        const color1D = rEq.map((rv, i) => {
          // center z around 0.5 so it tints up/down around the base radius color
          const tint = (zNorm[i] - 0.5) * AXIAL_AMOUNT * wFlat[i];
          return Math.min(1, Math.max(0, rv + tint));
        });

        // Expand to 2D for Plotly
        const surfacecolorDark = theta.map(() => color1D);

        // Dark-mode colorscale (many stops so large regions don't look flat)
        const darkSurfaceScale = [
          [0.0, "#FFBC0A"],
          [0.11, "#F69D0D"],
          [0.22, "#EC7D10"],
          [0.33, "#F45608"],
          [0.44, "#FC2F00"],
          [0.55, "#F41C34"],
          [0.66, "#EC0868"],
          [0.77, "#E2068D"],
          [0.88, "#D704B2"],
          [1.0, "#C200FB"],
        ];

        const surf = isDark
          ? {
              type: "surface",
              x: X,
              y: Y,
              z: Zgrid,
              surfacecolor: surfacecolorDark, // radius baseline + axial tint on flats
              cmin: 0,
              cmax: 1,
              colorscale: darkSurfaceScale, // <-- Coolors palette
              showscale: false,
              contours: { z: { show: false } },
              opacity: 1.0,
              lighting: {
                ambient: 0.9,
                diffuse: 1.0,
                specular: 0.45,
                roughness: 0.65,
                fresnel: 0.08,
              },
              lightposition: { x: 150, y: 0, z: 300 },
            }
          : {
              // LIGHT MODE: unchanged
              type: "surface",
              x: X,
              y: Y,
              z: Zgrid,
              showscale: false,
              contours: { z: { show: false } },
              opacity: 1.0,
            };

        // --- super tight framing and close camera (≈5× bigger) ---
        const zReach = Math.max(zThroat - zMinAll, zMaxAll - zThroat);

        // tiny padding so nothing clips
        const PAD = 0.02; // 2% pad
        const SCALE = 0.22; // camera distance factor (~5× bigger). Tweak 0.18–0.28 if needed.

        const xHalf = rMaxAll * (1 + PAD);
        const yHalf = rMaxAll * (1 + PAD);
        const zHalf = zReach * (1 + PAD);

        // pull the camera in hard so the model fills the plot
        const Rxz = SCALE * Math.max(rMaxAll, zReach);
        const Yorbit = SCALE * rMaxAll;

        const scene = {
          xaxis: { visible: false, range: [-xHalf, xHalf] },
          yaxis: { visible: false, range: [-yHalf, yHalf] },
          zaxis: { visible: false, range: [-zHalf, zHalf] },
          aspectmode: "data",
          dragmode: "orbit",
          camera: {
            // orbit around Y (throat-centered coords already used in Zgrid)
            eye: { x: Rxz, y: Yorbit, z: 0 },
            up: { x: 0, y: 1, z: 0 },
            projection: { type: "orthographic" }, // makes it appear larger (no perspective shrink)
          },
        };

        const plot3dEl = document.getElementById("plot3d");

        const plot3dLayout = isDark
          ? {
              scene,
              margin: { l: 0, r: 0, t: 0, b: 0 },
              paper_bgcolor:
                getComputedStyle(document.body)
                  .getPropertyValue("--bg")
                  .trim() || "#0b0f19",
              plot_bgcolor:
                getComputedStyle(document.body)
                  .getPropertyValue("--bg")
                  .trim() || "#0b0f19",
              template: "plotly_dark",
              font: {
                family:
                  getComputedStyle(document.body)
                    .getPropertyValue("--font")
                    .trim() ||
                  "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif",
                size: 13,
                color: "#cbd5e1",
              },
            }
          : {
              // LIGHT MODE: unchanged look
              scene,
              margin: { l: 0, r: 0, t: 0, b: 0 },
            };

        Plotly.newPlot(plot3dEl, [surf], plot3dLayout, {
          responsive: true,
          scrollZoom: true,
          displaylogo: false,
        });

        const R_ch = Math.sqrt(eps_c) * R_t; // chamber barrel radius
        const yAxis = {
          title: "Radial Length (in)",
          range: [0, Math.max(3 * R_ch, 1.05 * rMaxAll)],
        };

        const xAxis = {
          title: "Axial Length (in)",
          range: [0, 1.05 * zMaxAll],
        };

        const plot2dLayout = isDark
          ? {
              xaxis: {
                ...xAxis,
                tickfont: { color: "#cbd5e1" },
                titlefont: { color: "#cbd5e1" },
                gridcolor: "#334155",
                zerolinecolor: "#475569",
                linecolor: "#94a3b8",
                linewidth: 1,
                mirror: true,
                automargin: true,
              },
              yaxis: {
                ...yAxis,
                tickfont: { color: "#cbd5e1" },
                titlefont: { color: "#cbd5e1" },
                gridcolor: "#334155",
                zerolinecolor: "#475569",
                linecolor: "#94a3b8",
                linewidth: 1,
                mirror: true,
                automargin: true,
              },
              showlegend: true,
              legend: {
                orientation: "h",
                x: 0.5,
                xanchor: "center",
                y: -0.18, // below the plotting area
                yanchor: "top",
                bgcolor: "rgba(0,0,0,0)",
                borderwidth: 0,
                font: {
                  family:
                    getComputedStyle(document.body)
                      .getPropertyValue("--font")
                      .trim() ||
                    "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif",
                  size: 13,
                  color: "#cbd5e1",
                },
              },
              margin: { l: 40, r: 10, t: 16, b: 90 }, // extra bottom space for legend
              paper_bgcolor:
                getComputedStyle(document.body)
                  .getPropertyValue("--bg")
                  .trim() || "#0b0f19",
              plot_bgcolor:
                getComputedStyle(document.body)
                  .getPropertyValue("--bg")
                  .trim() || "#0b0f19",
              template: "plotly_dark",
              font: {
                family:
                  getComputedStyle(document.body)
                    .getPropertyValue("--font")
                    .trim() ||
                  "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif",
                size: 13,
                color: "#cbd5e1",
              },
            }
          : {
              xaxis: { ...xAxis, automargin: true },
              yaxis: { ...yAxis, automargin: true },
              showlegend: true,
              legend: {
                orientation: "h",
                x: 0.5,
                xanchor: "center",
                y: -0.18, // below the plotting area
                yanchor: "top",
                bgcolor: "rgba(0,0,0,0)",
                borderwidth: 0,
              },
              margin: { l: 40, r: 10, t: 16, b: 90 }, // extra bottom space for legend
            };

        const colorsLight = {
          chamber: "#26a9e0", // (your original)
          entrance: "#e61950",
          converging: "#f7a829",
          throat: "#fa791b",
          diverging: "#510c7c",
          nozzle: "#092843",
        };

        const colorsDark = {
          chamber: "#00E5FF", // neon cyan
          entrance: "#FF4D6D", // hot pink/red
          converging: "#FDEA45", // punchy yellow
          throat: "#FF8A00", // vivid orange
          diverging: "#C084FC", // bright violet
          nozzle: "#60A5FA", // bright blue
        };

        const C = isDark ? colorsDark : colorsLight;

        Plotly.newPlot(
          "plot",
          [
            {
              x: f1z,
              y: f1r,
              mode: "lines",
              line: { width: 3, color: C.chamber },
              name: "Chamber",
            },
            {
              x: f2z,
              y: f2r,
              mode: "lines",
              line: { width: 3, color: C.entrance },
              name: "Entrance Arc",
            },
            {
              x: f3z,
              y: f3r,
              mode: "lines",
              line: { width: 3, color: C.converging },
              name: "Converging Linear",
            },
            {
              x: f4z,
              y: f4r,
              mode: "lines",
              line: { width: 3, color: C.throat },
              name: "Throat Arc",
            },
            {
              x: f5z,
              y: f5r,
              mode: "lines",
              line: { width: 3, color: C.diverging },
              name: "Diverging Entrance",
            },
            {
              x: f6z,
              y: f6r,
              mode: "lines",
              line: { width: 3, color: C.nozzle },
              name: "Nozzle",
            },
          ],
          plot2dLayout,
          { responsive: true }
        );

        // --- Calculations ---
        let At = Math.PI * R_t ** 2;
        let Ainj = Math.PI * f1r[0] ** 2;
        let Aexit = Math.PI * f6r[f6r.length - 1] ** 2;
        let Lconv = f4z[f4z.length - 1] - f2z[0];
        let Lnoz = f6z[f6z.length - 1] - f4z[f4z.length - 1];
        // Merge all chamber-to-throat contour segments
        let chamberZ = [].concat(f1z, f2z.slice(1), f3z.slice(1), f4z.slice(1));
        let chamberR = [].concat(f1r, f2r.slice(1), f3r.slice(1), f4r.slice(1));

        // Volume of revolution (disk method)
        let vol = 0;
        for (let i = 0; i < chamberZ.length - 1; i++) {
          let dx = chamberZ[i + 1] - chamberZ[i];
          vol +=
            ((Math.PI * (chamberR[i] ** 2 + chamberR[i + 1] ** 2)) / 2) * dx;
        }

        let Lstar = vol / At;

        document.getElementById("outputs").innerHTML = `
          Throat Area: ${At.toFixed(3)} in²<br>
          Injector Area: ${Ainj.toFixed(3)} in²<br>
          Exit Area: ${Aexit.toFixed(3)} in²<br>
          Converging Length: ${Lconv.toFixed(3)} in<br>
          Nozzle Length: ${Lnoz.toFixed(3)} in<br>
          Chamber Volume: ${vol.toFixed(3)} in³<br>
          Characteristic Length (L*): ${Lstar.toFixed(3)} in
        `;
      }

      function downloadCSV() {
        if (!window.currentContour) return;
        let { z, r } = window.currentContour;
        let rows = ["Z,R"];
        for (let i = 0; i < z.length; i++) rows.push(`${z[i]},${r[i]}`);
        let blob = new Blob([rows.join("\n")], { type: "text/csv" });
        let url = URL.createObjectURL(blob);
        let a = document.createElement("a");
        a.href = url;
        a.download = "contour.csv";
        a.click();
      }

      // === STL EXPORT: outward-only thickness; inner surface is exactly the original contour; NO END CAPS ===
      function downloadSTL() {
        if (!window.currentContour) return;

        const { z, r, zThroat } = window.currentContour;
        const t =
          Math.max(
            0,
            parseFloat(document.getElementById("wall_t_val").value || "0")
          ) || 0;

        if (t === 0) {
          return exportSingleSurfaceSTL(z, r, zThroat);
        }
        // Smoother revolve -> bigger file. 180 is a good default.
        const nTheta = 180;
        const twoPi = Math.PI * 2;

        // Center along Z same as 3D plot
        const zi = z.map((zz) => zz - zThroat);
        const riInner = r.slice(); // inner is EXACTLY the plotted contour
        const riOuter = r.map((rv) => rv + t); // thickness only added outward (radially)

        const facets = [];

        function normal(a, b, c) {
          const ux = b[0] - a[0],
            uy = b[1] - a[1],
            uz = b[2] - a[2];
          const vx = c[0] - a[0],
            vy = c[1] - a[1],
            vz = c[2] - a[2];
          const nx = uy * vz - uz * vy;
          const ny = uz * vx - ux * vz;
          const nz = ux * vy - uy * vx;
          const len = Math.hypot(nx, ny, nz) || 1;
          return [nx / len, ny / len, nz / len];
        }
        function addTri(v0, v1, v2) {
          const n = normal(v0, v1, v2);
          facets.push([n, v0, v1, v2]);
        }
        function addTriFlipped(v0, v1, v2) {
          // reverse winding (use for inner surface so normals face OUT of the solid)
          addTri(v0, v2, v1);
        }

        // Helper: guard against degenerate ring segments (nearly zero radius)
        const EPS = 1e-9;
        function segmentValid(r0, r1) {
          return Math.abs(r0) > EPS || Math.abs(r1) > EPS;
        }

        // === Build side surfaces only (no caps) ===
        for (let tIdx = 0; tIdx < nTheta; tIdx++) {
          const th0 = (tIdx * twoPi) / nTheta;
          const th1 = ((tIdx + 1) * twoPi) / nTheta;
          const c0 = Math.cos(th0),
            s0 = Math.sin(th0);
          const c1 = Math.cos(th1),
            s1 = Math.sin(th1);

          for (let i = 0; i < zi.length - 1; i++) {
            const z0 = zi[i],
              z1 = zi[i + 1];

            // ---- OUTER SURFACE (normals outward) ----
            const r0o = riOuter[i],
              r1o = riOuter[i + 1];
            if (segmentValid(r0o, r1o)) {
              const v00o = [r0o * c0, r0o * s0, z0];
              const v01o = [r0o * c1, r0o * s1, z0];
              const v10o = [r1o * c0, r1o * s0, z1];
              const v11o = [r1o * c1, r1o * s1, z1];

              // Consistent winding so normals point radially outward
              addTri(v00o, v01o, v11o);
              addTri(v00o, v11o, v10o);
            }

            // ---- INNER SURFACE (reverse winding so normals point OUT of the solid i.e., toward the cavity) ----
            const r0i = riInner[i],
              r1i = riInner[i + 1];
            if (segmentValid(r0i, r1i)) {
              const v00i = [r0i * c0, r0i * s0, z0];
              const v01i = [r0i * c1, r0i * s1, z0];
              const v10i = [r1i * c0, r1i * s0, z1];
              const v11i = [r1i * c1, r1i * s1, z1];

              // Flip winding relative to outer so normals face into the hollow (correct "outward from solid")
              addTriFlipped(v00i, v01i, v11i);
              addTriFlipped(v00i, v11i, v10i);
            }
          }
        }

        // NOTE: We intentionally do NOT add end-caps.
        // This keeps the shell open at both ends and avoids rim-normal confusion in CAD/slicers.
        // If you later want a closed, watertight solid, we can add properly-oriented annular rims.

        // OPTIONAL: add end caps to make a closed shell
        function addEndCaps(zi, riInner, riOuter, nTheta, facets) {
          const twoPi = Math.PI * 2;

          function normal(a, b, c) {
            const ux = b[0] - a[0],
              uy = b[1] - a[1],
              uz = b[2] - a[2];
            const vx = c[0] - a[0],
              vy = c[1] - a[1],
              vz = c[2] - a[2];
            const nx = uy * vz - uz * vy,
              ny = uz * vx - ux * vz,
              nz = ux * vy - uy * vx;
            const len = Math.hypot(nx, ny, nz) || 1;
            return [nx / len, ny / len, nz / len];
          }
          function addTri(v0, v1, v2) {
            facets.push([normal(v0, v1, v2), v0, v1, v2]);
          }

          // Start ring (lower z) — normal ~ -Z
          {
            const i = 0,
              z0 = zi[i];
            for (let tIdx = 0; tIdx < nTheta; tIdx++) {
              const th0 = (tIdx * twoPi) / nTheta,
                th1 = ((tIdx + 1) * twoPi) / nTheta;
              const c0 = Math.cos(th0),
                s0 = Math.sin(th0),
                c1 = Math.cos(th1),
                s1 = Math.sin(th1);
              const ro = riOuter[i],
                ri = riInner[i];

              const o0 = [ro * c0, ro * s0, z0],
                o1 = [ro * c1, ro * s1, z0];
              const i0 = [ri * c0, ri * s0, z0],
                i1 = [ri * c1, ri * s1, z0];

              addTri(o0, i1, o1);
              addTri(o0, i0, i1);
            }
          }

          // End ring (higher z) — normal ~ +Z
          {
            const i = zi.length - 1,
              z1 = zi[i];
            for (let tIdx = 0; tIdx < nTheta; tIdx++) {
              const th0 = (tIdx * twoPi) / nTheta,
                th1 = ((tIdx + 1) * twoPi) / nTheta;
              const c0 = Math.cos(th0),
                s0 = Math.sin(th0),
                c1 = Math.cos(th1),
                s1 = Math.sin(th1);
              const ro = riOuter[i],
                ri = riInner[i];

              const o0 = [ro * c0, ro * s0, z1],
                o1 = [ro * c1, ro * s1, z1];
              const i0 = [ri * c0, ri * s0, z1],
                i1 = [ri * c1, ri * s1, z1];

              addTri(o0, o1, i1);
              addTri(o0, i1, i0);
            }
          }
        }

        addEndCaps(zi, riInner, riOuter, nTheta, facets);

        // ASCII STL
        let stl = "solid nozzle_shell\n";
        for (const [n, a, b, c] of facets) {
          stl += ` facet normal ${n[0]} ${n[1]} ${n[2]}\n`;
          stl += "  outer loop\n";
          stl += `   vertex ${a[0]} ${a[1]} ${a[2]}\n`;
          stl += `   vertex ${b[0]} ${b[1]} ${b[2]}\n`;
          stl += `   vertex ${c[0]} ${c[1]} ${c[2]}\n`;
          stl += "  endloop\n";
          stl += " endfacet\n";
        }
        stl += "endsolid nozzle_shell\n";

        const blob = new Blob([stl], { type: "application/sla" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `nozzle_shell_t${t.toFixed(3)}in.stl`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function exportSingleSurfaceSTL(z, r, zThroat) {
        const nTheta = 180;
        const twoPi = Math.PI * 2;

        const zi = z.map((zz) => zz - zThroat);
        const facets = [];

        function normal(a, b, c) {
          const ux = b[0] - a[0],
            uy = b[1] - a[1],
            uz = b[2] - a[2];
          const vx = c[0] - a[0],
            vy = c[1] - a[1],
            vz = c[2] - a[2];
          const nx = uy * vz - uz * vy,
            ny = uz * vx - ux * vz,
            nz = ux * vy - uy * vx;
          const len = Math.hypot(nx, ny, nz) || 1;
          return [nx / len, ny / len, nz / len];
        }
        function addTri(v0, v1, v2) {
          facets.push([normal(v0, v1, v2), v0, v1, v2]);
        }

        for (let tIdx = 0; tIdx < nTheta; tIdx++) {
          const th0 = (tIdx * twoPi) / nTheta,
            th1 = ((tIdx + 1) * twoPi) / nTheta;
          const c0 = Math.cos(th0),
            s0 = Math.sin(th0),
            c1 = Math.cos(th1),
            s1 = Math.sin(th1);
          for (let i = 0; i < zi.length - 1; i++) {
            const z0 = zi[i],
              z1 = zi[i + 1];
            const r0 = r[i],
              r1 = r[i + 1];
            const v00 = [r0 * c0, r0 * s0, z0],
              v01 = [r0 * c1, r0 * s1, z0];
            const v10 = [r1 * c0, r1 * s0, z1],
              v11 = [r1 * c1, r1 * s1, z1];
            addTri(v00, v01, v11);
            addTri(v00, v11, v10);
          }
        }

        let stl = "solid nozzle_surface\n";
        for (const [n, a, b, c] of facets) {
          stl += ` facet normal ${n[0]} ${n[1]} ${n[2]}\n  outer loop\n`;
          stl += `   vertex ${a[0]} ${a[1]} ${a[2]}\n   vertex ${b[0]} ${b[1]} ${b[2]}\n   vertex ${c[0]} ${c[1]} ${c[2]}\n`;
          stl += "  endloop\n endfacet\n";
        }
        stl += "endsolid nozzle_surface\n";

        const blob = new Blob([stl], { type: "application/sla" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "nozzle_surface.stl";
        a.click();
        URL.revokeObjectURL(url);
      }

      updatePlot();
    </script>
  </body>
</html>
