<!DOCTYPE html>
<html>
  <head>
    <title>Nozzle Contour Generator</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
      .meta-row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 6px 0 10px 0; /* small breathing room */
      }

      .byline {
        margin: 0; /* keep the row tight */
      }

      .theme-toggle {
        border: 1px solid var(--border);
        background: var(--panel);
        color: var(--text);
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
      }

      body {
        font-family: sans-serif;
        margin: 20px;
        display: flex;
        flex-direction: row;
        gap: 40px;
      }
      #controls {
        display: flex;
        flex-direction: column;
        width: 320px;
      }
      label {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
      }
      .input-row {
        display: flex;
        gap: 5px;
        align-items: center;
      }
      input[type="range"] {
        flex: 1;
      }
      input[type="number"] {
        width: 70px;
      }
      #outputs {
        margin-top: 20px;
        font-size: 14px;
      }
      h1 {
        margin-bottom: 0;
      }
      h2 {
        margin-top: 40px;
        margin-bottom: 10px;
      }
    </style>

    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />

    <style>
      /* THEME TOKENS */
      :root {
        --bg: #0b0f19; /* dark default */
        --panel: #111827;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --accent: #22d3ee;
        --input: #1f2937;
        --border: #334155;
        --link: #38bdf8;
        --font: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial,
          sans-serif;
      }
      [data-theme="light"] {
        --bg: #ffffff;
        --panel: #f8fafc;
        --text: #0f172a;
        --muted: #475569;
        --accent: #0ea5e9;
        --input: #ffffff;
        --border: #e2e8f0;
        --link: #0284c7;
      }

      /* APPLY TOKENS */
      body {
        background: var(--bg);
        color: var(--text);
        font-family: var(--font);
      }
      #controls label {
        color: var(--text);
      }
      #controls .input-row input[type="number"],
      #controls .input-row input[type="range"],
      #controls select {
        background: var(--input);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 6px 8px;
      }
      #controls button {
        background: var(--accent);
        color: #001018;
        border: 0;
        border-radius: 10px;
        padding: 10px 12px;
        margin-top: 14px;
        cursor: pointer;
      }
      a {
        color: var(--link);
      }
      #vizRow {
        background: transparent;
      }
    </style>
  </head>
  <body data-theme="light">
    <div>
      <h1 style="display: flex; align-items: center; gap: 12px">
        Nozzle Contour Generator
      </h1>
      <div class="meta-row">
        <p class="byline"><em>By Saaketh Ramoju</em></p>
        <button id="themeToggle" class="theme-toggle">Light mode</button>
      </div>

      <div id="controls">
        <label
          >Nozzle Shape:
          <select id="b_or_c" onchange="updatePlot()">
            <option value="Conical">Conical</option>
            <option value="Bell">Bell</option>
          </select>
        </label>

        <!-- Example with slider + number input -->
        <label
          >Throat Radius (in):
          <div class="input-row">
            <input
              id="R_t"
              type="range"
              min="0.1"
              max="15"
              step="0.001"
              value="1"
              oninput="syncInput('R_t')"
            />
            <input
              id="R_t_num"
              type="number"
              min="0.1"
              max="15"
              step="0.001"
              value="1"
              oninput="syncSlider('R_t')"
            />
          </div>
        </label>

        <label
          >Chamber Cylindrical Length (in):
          <div class="input-row">
            <input
              id="Lc"
              type="range"
              min="1"
              max="100"
              step="0.001"
              value="10"
              oninput="syncInput('Lc')"
            />
            <input
              id="Lc_num"
              type="number"
              min="1"
              max="100"
              step="0.001"
              value="10"
              oninput="syncSlider('Lc')"
            />
          </div>
        </label>

        <label
          >Contraction Ratio:
          <div class="input-row">
            <input
              id="eps_c"
              type="range"
              min="1.5"
              max="5"
              step="0.001"
              value="3.8"
              oninput="syncInput('eps_c')"
            />
            <input
              id="eps_c_num"
              type="number"
              min="1.5"
              max="5"
              step="0.001"
              value="3.8"
              oninput="syncSlider('eps_c')"
            />
          </div>
        </label>

        <label
          >Convergence Half-Angle (°):
          <div class="input-row">
            <input
              id="theta_c"
              type="range"
              min="10"
              max="50"
              step="0.001"
              value="37.5"
              oninput="syncInput('theta_c')"
            />
            <input
              id="theta_c_num"
              type="number"
              min="10"
              max="50"
              step="0.001"
              value="37.5"
              oninput="syncSlider('theta_c')"
            />
          </div>
        </label>

        <label
          >Convergence Radius Rc/Rt:
          <div class="input-row">
            <input
              id="Rc_Rt"
              type="range"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncInput('Rc_Rt')"
            />
            <input
              id="Rc_Rt_num"
              type="number"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncSlider('Rc_Rt')"
            />
          </div>
        </label>

        <label
          >Lead-in Radius Rtc/Rt:
          <div class="input-row">
            <input
              id="Rtc_Rt"
              type="range"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncInput('Rtc_Rt')"
            />
            <input
              id="Rtc_Rt_num"
              type="number"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncSlider('Rtc_Rt')"
            />
          </div>
        </label>

        <label
          >Lead-out Radius Rtd/Rt:
          <div class="input-row">
            <input
              id="Rtd_Rt"
              type="range"
              min="0.1"
              max="4"
              step="0.001"
              value="0.5"
              oninput="syncInput('Rtd_Rt')"
            />
            <input
              id="Rtd_Rt_num"
              type="number"
              min="0.1"
              max="4"
              step="0.001"
              value="0.5"
              oninput="syncSlider('Rtd_Rt')"
            />
          </div>
        </label>

        <label
          >Expansion Ratio:
          <div class="input-row">
            <input
              id="eps"
              type="range"
              min="2"
              max="100"
              step="0.001"
              value="4"
              oninput="syncInput('eps')"
            />
            <input
              id="eps_num"
              type="number"
              min="2"
              max="100"
              step="0.001"
              value="4"
              oninput="syncSlider('eps')"
            />
          </div>
        </label>

        <label
          >Divergence Half-Angle (°) [Conical]:
          <div class="input-row">
            <input
              id="alpha"
              type="range"
              min="5"
              max="60"
              step="0.001"
              value="15"
              oninput="syncInput('alpha')"
            />
            <input
              id="alpha_num"
              type="number"
              min="5"
              max="60"
              step="0.001"
              value="15"
              oninput="syncSlider('alpha')"
            />
          </div>
        </label>

        <label
          >Divergence Entrance Angle (°) [Bell]:
          <div class="input-row">
            <input
              id="theta_n"
              type="range"
              min="10"
              max="80"
              step="0.001"
              value="22"
              oninput="syncInput('theta_n')"
            />
            <input
              id="theta_n_num"
              type="number"
              min="10"
              max="80"
              step="0.001"
              value="22"
              oninput="syncSlider('theta_n')"
            />
          </div>
        </label>

        <label
          >Divergence Exit Angle (°) [Bell]:
          <div class="input-row">
            <input
              id="theta_e"
              type="range"
              min="0"
              max="50"
              step="0.001"
              value="10"
              oninput="syncInput('theta_e')"
            />
            <input
              id="theta_e_num"
              type="number"
              min="0"
              max="50"
              step="0.001"
              value="10"
              oninput="syncSlider('theta_e')"
            />
          </div>
        </label>

        <label
          >Percent Bell Lf (%):
          <div class="input-row">
            <input
              id="Lf"
              type="range"
              min="60"
              max="100"
              step="0.001"
              value="80"
              oninput="syncInput('Lf')"
            />
            <input
              id="Lf_num"
              type="number"
              min="60"
              max="100"
              step="0.001"
              value="80"
              oninput="syncSlider('Lf')"
            />
          </div>
        </label>

        <button onclick="downloadCSV()">Download Contour CSV</button>
      </div>
    </div>

    <div style="flex: 1; min-width: 0">
      <div
        id="vizRow"
        style="
          display: flex;
          flex-direction: row;
          gap: 16px;
          align-items: flex-start;
          width: 100%;
        "
      >
        <!-- leave ~420px for the controls column -->
        <div id="plot" style="flex: 1; min-width: 0; height: 520px"></div>
        <div id="plot3d" style="flex: 1; min-width: 0; height: 520px"></div>
      </div>
      <h2>Calculated Values</h2>
      <div id="outputs"></div>
    </div>

    <script>
      // THEME HELPERS
      function setTheme(t) {
        document.body.setAttribute("data-theme", t);
        localStorage.setItem("nozzle_theme", t);
        const btn = document.getElementById("themeToggle");
        if (btn) btn.textContent = t === "dark" ? "Light mode" : "Dark mode";
      }
      function getTheme() {
        return document.body.getAttribute("data-theme") || "dark";
      }
      // init theme on load
      (function initTheme() {
        const saved = localStorage.getItem("nozzle_theme");
        if (saved === "light" || saved === "dark") {
          document.body.setAttribute("data-theme", saved);
        } else {
          document.body.setAttribute("data-theme", "light"); // default to light
        }
        window.addEventListener("DOMContentLoaded", () => {
          const btn = document.getElementById("themeToggle");
          if (btn) {
            btn.addEventListener("click", () => {
              setTheme(getTheme() === "dark" ? "light" : "dark");
              updatePlot(); // re-render plots with new template/colors
            });
            // reflect initial label
            btn.textContent =
              getTheme() === "dark" ? "Light mode" : "Dark mode";
          }
        });
      })();

      // keep number and slider in sync
      function syncInput(id) {
        document.getElementById(id + "_num").value =
          document.getElementById(id).value;
        updatePlot();
      }
      function syncSlider(id) {
        document.getElementById(id).value = document.getElementById(
          id + "_num"
        ).value;
        updatePlot();
      }

      function getVal(id) {
        return parseFloat(document.getElementById(id).value);
      }

      function linspace(start, stop, n) {
        return Array.from(
          { length: n },
          (_, i) => start + ((stop - start) * i) / (n - 1)
        );
      }

      function updatePlot() {
        let b_or_c = document.getElementById("b_or_c").value;
        let R_t = getVal("R_t");
        let Lc = getVal("Lc");
        let eps_c = getVal("eps_c");
        let theta_c = (getVal("theta_c") * Math.PI) / 180;
        let Rc = getVal("Rc_Rt") * R_t;
        let Rtc = getVal("Rtc_Rt") * R_t;
        let Rtd = getVal("Rtd_Rt") * R_t;
        let eps = getVal("eps");
        let alpha = (getVal("alpha") * Math.PI) / 180;
        let theta_n = (getVal("theta_n") * Math.PI) / 180;
        let theta_e = (getVal("theta_e") * Math.PI) / 180;
        let Lf = getVal("Lf");

        // --- Geometry sections (same as before) ---
        let f1z = linspace(0, Lc, 200);
        let f1r = f1z.map(() => Math.sqrt(eps_c) * R_t);
        let t2 = linspace(Math.PI / 2, Math.PI / 2 - theta_c, 200);
        let f2z = t2.map((tt) => Rc * Math.cos(tt) + Lc);
        let f2r = t2.map(
          (tt) => Rc * Math.sin(tt) + Math.sqrt(eps_c) * R_t - Rc
        );
        let y3 =
          R_t * (Math.sqrt(eps_c) - 1) -
          (Rc - Rc * Math.cos(theta_c)) -
          (Rtc - Rtc * Math.cos(theta_c));
        let x3 = y3 / Math.tan(theta_c);
        let f3z = linspace(f2z[f2z.length - 1], f2z[f2z.length - 1] + x3, 200);
        let m3 = -Math.tan(theta_c);
        let f3r = f3z.map(
          (z) => m3 * (z - f2z[f2z.length - 1]) + f2r[f2r.length - 1]
        );
        let h = f3z[f3z.length - 1] + Rtc * Math.sin(theta_c);
        let k = R_t + Rtc;
        let t4 = linspace(
          Math.PI + Math.PI / 2 - theta_c,
          (3 * Math.PI) / 2,
          200
        );
        let f4z = t4.map((tt) => Rtc * Math.cos(tt) + h);
        let f4r = t4.map((tt) => Rtc * Math.sin(tt) + k);

        const zThroat = f4z[f4z.length - 1];

        let f5z, f5r;
        if (b_or_c == "Conical") {
          let t5 = linspace((3 * Math.PI) / 2, (3 * Math.PI) / 2 + alpha, 200);
          f5z = t5.map((tt) => Rtd * Math.cos(tt) + h);
          f5r = t5.map((tt) => Rtd * Math.sin(tt) + R_t + Rtd);
        } else {
          let t5 = linspace(
            (3 * Math.PI) / 2,
            (3 * Math.PI) / 2 + theta_n,
            200
          );
          f5z = t5.map((tt) => Rtd * Math.cos(tt) + h);
          f5r = t5.map((tt) => Rtd * Math.sin(tt) + R_t + Rtd);
        }

        let f6z, f6r;
        if (b_or_c == "Conical") {
          let length =
            (Math.sqrt(eps) * R_t - f5r[f5r.length - 1]) / Math.tan(alpha);
          f6z = linspace(
            f5z[f5z.length - 1],
            f5z[f5z.length - 1] + length,
            200
          );
          let m6 = Math.tan(alpha);
          f6r = f6z.map(
            (z) => m6 * (z - f5z[f5z.length - 1]) + f5r[f5r.length - 1]
          );
        } else {
          let N = [f5z[f5z.length - 1], f5r[f5r.length - 1]];
          let E = [
            (Lf / 100) *
              ((Math.sqrt(eps) * R_t - f5r[f5r.length - 1]) /
                Math.tan((15 * Math.PI) / 180)) +
              f4z[f4z.length - 1],
            Math.sqrt(eps) * R_t,
          ];
          let m1 = Math.tan(theta_n),
            m2 = Math.tan(theta_e);
          let Qx = (m1 * N[0] - N[1] - m2 * E[0] + E[1]) / (m1 - m2);
          let Qy = m1 * (Qx - N[0]) + N[1];
          let t = linspace(0, 1, 200);
          f6z = t.map(
            (tt) =>
              (1 - tt) ** 2 * N[0] + 2 * (1 - tt) * tt * Qx + tt ** 2 * E[0]
          );
          f6r = t.map(
            (tt) =>
              (1 - tt) ** 2 * N[1] + 2 * (1 - tt) * tt * Qy + tt ** 2 * E[1]
          );
        }

        let z = [].concat(
          f1z,
          f2z.slice(1),
          f3z.slice(1),
          f4z.slice(1),
          f5z.slice(1),
          f6z.slice(1)
        );
        let r = [].concat(
          f1r,
          f2r.slice(1),
          f3r.slice(1),
          f4r.slice(1),
          f5r.slice(1),
          f6r.slice(1)
        );
        window.currentContour = { z, r };

        // ==== THEME VARS FOR PLOTS ====
        const theme = getTheme();

        const template = theme === "dark" ? "plotly_dark" : "plotly_white";
        const paperBG =
          getComputedStyle(document.body).getPropertyValue("--bg").trim() ||
          (theme === "dark" ? "#0b0f19" : "#ffffff");
        const plotBG = paperBG; // match paper

        // ==== HIGH-CONTRAST PLOT COLORS (dark mode) ====
        const isDark = getTheme() === "dark";
        const axisColor = isDark ? "#cbd5e1" : undefined; // light slate
        const gridColor = isDark ? "#334155" : undefined; // slate-700
        const zeroColor = isDark ? "#475569" : undefined; // slate-600
        const lineColor = isDark ? "#94a3b8" : undefined; // slate-400
        const fontFamily =
          getComputedStyle(document.body).getPropertyValue("--font").trim() ||
          "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
        const baseFont = { family: fontFamily, size: 13, color: axisColor };

        // ---- shared extents (unique names so they won't collide) ----
        const zMinAll = Math.min(...z);
        const zMaxAll = Math.max(...z);
        const rMaxAll = Math.max(...r);

        // ===== 3D solid-of-revolution (throat-centered, y-axis orbit) =====
        const nTheta = 72;
        const theta = linspace(0, 2 * Math.PI, nTheta);
        const X = theta.map((th) => r.map((ri) => ri * Math.cos(th)));
        const Y = theta.map((th) => r.map((ri) => ri * Math.sin(th)));
        const Zgrid = theta.map(() => z.map((zi) => zi - zThroat));
        const Rgrid = theta.map(() => r.slice()); // same shape as X/Y/Z

        // High-contrast (no pink) dark-mode colorscale: blue → cyan → lime → yellow → white
        const darkSurfaceScale = [
          [0.0, "#CDB4DB"],
          [0.25, "#FFC8DD"],
          [0.5, "#FFAFCC"],
          [0.75, "#BDE0FE"],
          [1.0, "#A2D2FF"],
        ];

        const surf = isDark
          ? {
              type: "surface",
              x: X,
              y: Y,
              z: Zgrid,
              surfacecolor: Rgrid, // use radius for vivid bands
              cmin: 0,
              cmax: rMaxAll,
              colorscale: darkSurfaceScale, // << no pink
              showscale: false,
              contours: { z: { show: false } },
              opacity: 1.0,
              // brighter but not blown out
              lighting: {
                ambient: 0.9,
                diffuse: 1.0,
                specular: 0.45,
                roughness: 0.65,
                fresnel: 0.08,
              },
              lightposition: { x: 150, y: 0, z: 300 },
            }
          : {
              // LIGHT MODE: unchanged
              type: "surface",
              x: X,
              y: Y,
              z: Zgrid,
              showscale: false,
              contours: { z: { show: false } },
              opacity: 1.0,
            };

        // --- super tight framing and close camera (≈5× bigger) ---
        const zReach = Math.max(zThroat - zMinAll, zMaxAll - zThroat);

        // tiny padding so nothing clips
        const PAD = 0.02; // 2% pad
        const SCALE = 0.22; // camera distance factor (~5× bigger). Tweak 0.18–0.28 if needed.

        const xHalf = rMaxAll * (1 + PAD);
        const yHalf = rMaxAll * (1 + PAD);
        const zHalf = zReach * (1 + PAD);

        // pull the camera in hard so the model fills the plot
        const Rxz = SCALE * Math.max(rMaxAll, zReach);
        const Yorbit = SCALE * rMaxAll;

        const scene = {
          xaxis: { visible: false, range: [-xHalf, xHalf] },
          yaxis: { visible: false, range: [-yHalf, yHalf] },
          zaxis: { visible: false, range: [-zHalf, zHalf] },
          aspectmode: "data",
          dragmode: "orbit",
          camera: {
            // orbit around Y (throat-centered coords already used in Zgrid)
            eye: { x: Rxz, y: Yorbit, z: 0 },
            up: { x: 0, y: 1, z: 0 },
            projection: { type: "orthographic" }, // makes it appear larger (no perspective shrink)
          },
        };

        const plot3dEl = document.getElementById("plot3d");

        const plot3dLayout = isDark
          ? {
              scene,
              margin: { l: 0, r: 0, t: 0, b: 0 },
              paper_bgcolor:
                getComputedStyle(document.body)
                  .getPropertyValue("--bg")
                  .trim() || "#0b0f19",
              plot_bgcolor:
                getComputedStyle(document.body)
                  .getPropertyValue("--bg")
                  .trim() || "#0b0f19",
              template: "plotly_dark",
              font: {
                family:
                  getComputedStyle(document.body)
                    .getPropertyValue("--font")
                    .trim() ||
                  "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif",
                size: 13,
                color: "#cbd5e1",
              },
            }
          : {
              // LIGHT MODE: unchanged look
              scene,
              margin: { l: 0, r: 0, t: 0, b: 0 },
            };

        Plotly.newPlot(plot3dEl, [surf], plot3dLayout, {
          responsive: true,
          scrollZoom: true,
          displaylogo: false,
        });

        // Stop auto-rotation the instant the user changes the camera (pan/zoom/orbit)
        plot3dEl.on("plotly_relayouting", () => {
          stopRotation();
        });
        plot3dEl.on("plotly_relayout", (e) => {
          // If the relayout event touched camera or axis ranges, stop rotation
          if (
            e &&
            Object.keys(e).some(
              (k) =>
                k.startsWith("scene.camera") ||
                k.includes("scene.xaxis.range") ||
                k.includes("scene.yaxis.range") ||
                k.includes("scene.zaxis.range")
            )
          ) {
            stopRotation();
          }
        });

        // Optional: double-click inside the 3D plot to resume autorotation
        plot3dEl.on("plotly_doubleclick", () => startRotation(Rxz, Yorbit));

        // (re)start auto-rotation around y-axis through the throat
        startRotation(Rxz, Yorbit);

        const R_ch = Math.sqrt(eps_c) * R_t; // chamber barrel radius
        const yAxis = {
          title: "Radial Length (in)",
          range: [0, Math.max(3 * R_ch, 1.05 * rMaxAll)],
        };

        const xAxis = {
          title: "Axial Length (in)",
          range: [0, 1.05 * zMaxAll],
        };

        const plot2dLayout = isDark
          ? {
              xaxis: {
                ...xAxis,
                tickfont: { color: "#cbd5e1" },
                titlefont: { color: "#cbd5e1" },
                gridcolor: "#334155",
                zerolinecolor: "#475569",
                linecolor: "#94a3b8",
                linewidth: 1,
                mirror: true,
              },
              yaxis: {
                ...yAxis,
                tickfont: { color: "#cbd5e1" },
                titlefont: { color: "#cbd5e1" },
                gridcolor: "#334155",
                zerolinecolor: "#475569",
                linecolor: "#94a3b8",
                linewidth: 1,
                mirror: true,
              },
              showlegend: true,
              legend: {
                font: {
                  family:
                    getComputedStyle(document.body)
                      .getPropertyValue("--font")
                      .trim() ||
                    "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif",
                  size: 13,
                  color: "#cbd5e1",
                },
              },
              margin: { l: 40, r: 10, t: 20, b: 40 },
              paper_bgcolor:
                getComputedStyle(document.body)
                  .getPropertyValue("--bg")
                  .trim() || "#0b0f19",
              plot_bgcolor:
                getComputedStyle(document.body)
                  .getPropertyValue("--bg")
                  .trim() || "#0b0f19",
              template: "plotly_dark",
              font: {
                family:
                  getComputedStyle(document.body)
                    .getPropertyValue("--font")
                    .trim() ||
                  "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif",
                size: 13,
                color: "#cbd5e1",
              },
            }
          : {
              // LIGHT MODE: unchanged
              xaxis: xAxis,
              yaxis: yAxis,
              showlegend: true,
              margin: { l: 40, r: 10, t: 20, b: 40 },
            };

        const colorsLight = {
          chamber: "#26a9e0", // (your original)
          entrance: "#e61950",
          converging: "#f7a829",
          throat: "#fa791b",
          diverging: "#510c7c",
          nozzle: "#092843",
        };

        const colorsDark = {
          chamber: "#00E5FF", // neon cyan
          entrance: "#FF4D6D", // hot pink/red
          converging: "#FDEA45", // punchy yellow
          throat: "#FF8A00", // vivid orange
          diverging: "#C084FC", // bright violet
          nozzle: "#60A5FA", // bright blue
        };

        const C = isDark ? colorsDark : colorsLight;

        Plotly.newPlot(
          "plot",
          [
            {
              x: f1z,
              y: f1r,
              mode: "lines",
              line: { width: 3, color: C.chamber },
              name: "Chamber",
            },
            {
              x: f2z,
              y: f2r,
              mode: "lines",
              line: { width: 3, color: C.entrance },
              name: "Entrance Arc",
            },
            {
              x: f3z,
              y: f3r,
              mode: "lines",
              line: { width: 3, color: C.converging },
              name: "Converging Linear",
            },
            {
              x: f4z,
              y: f4r,
              mode: "lines",
              line: { width: 3, color: C.throat },
              name: "Throat Arc",
            },
            {
              x: f5z,
              y: f5r,
              mode: "lines",
              line: { width: 3, color: C.diverging },
              name: "Diverging Entrance",
            },
            {
              x: f6z,
              y: f6r,
              mode: "lines",
              line: { width: 3, color: C.nozzle },
              name: "Nozzle",
            },
          ],
          plot2dLayout,
          { responsive: true }
        );

        // --- Calculations ---
        let At = Math.PI * R_t ** 2;
        let Ainj = Math.PI * f1r[0] ** 2;
        let Aexit = Math.PI * f6r[f6r.length - 1] ** 2;
        let Lconv = f4z[f4z.length - 1] - f2z[0];
        let Lnoz = f6z[f6z.length - 1] - f4z[f4z.length - 1];
        // Merge all chamber-to-throat contour segments
        let chamberZ = [].concat(f1z, f2z.slice(1), f3z.slice(1), f4z.slice(1));
        let chamberR = [].concat(f1r, f2r.slice(1), f3r.slice(1), f4r.slice(1));

        // Volume of revolution (disk method)
        let vol = 0;
        for (let i = 0; i < chamberZ.length - 1; i++) {
          let dx = chamberZ[i + 1] - chamberZ[i];
          vol +=
            ((Math.PI * (chamberR[i] ** 2 + chamberR[i + 1] ** 2)) / 2) * dx;
        }

        let Lstar = vol / At;

        document.getElementById("outputs").innerHTML = `
          Throat Area: ${At.toFixed(3)} in²<br>
          Injector Area: ${Ainj.toFixed(3)} in²<br>
          Exit Area: ${Aexit.toFixed(3)} in²<br>
          Converging Length: ${Lconv.toFixed(3)} in<br>
          Nozzle Length: ${Lnoz.toFixed(3)} in<br>
          Chamber Volume: ${vol.toFixed(3)} in³<br>
          Characteristic Length (L*): ${Lstar.toFixed(3)} in
        `;
      }

      function downloadCSV() {
        if (!window.currentContour) return;
        let { z, r } = window.currentContour;
        let rows = ["Z,R"];
        for (let i = 0; i < z.length; i++) rows.push(`${z[i]},${r[i]}`);
        let blob = new Blob([rows.join("\n")], { type: "text/csv" });
        let url = URL.createObjectURL(blob);
        let a = document.createElement("a");
        a.href = url;
        a.download = "contour.csv";
        a.click();
      }

      // ---- Auto-rotation helpers (ADDED) ----
      let rotTimer = null;
      let rotAngle = 0;

      function startRotation(Rxz, Yorbit) {
        if (rotTimer) {
          clearInterval(rotTimer);
          rotTimer = null;
        }
        rotTimer = setInterval(() => {
          rotAngle += 0.02; // speed
          const eye = {
            x: Rxz * Math.cos(rotAngle),
            y: Yorbit,
            z: Rxz * Math.sin(rotAngle),
          };
          Plotly.relayout("plot3d", {
            "scene.camera.eye": eye,
            "scene.camera.up": { x: 0, y: 1, z: 0 },
          });
        }, 30);
      }

      function stopRotation() {
        if (rotTimer) {
          clearInterval(rotTimer);
          rotTimer = null;
        }
      }

      updatePlot();
    </script>
  </body>
</html>
