<!DOCTYPE html>
<html>
  <head>
    <title>Nozzle Contour Generator</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
        display: flex;
        flex-direction: row;
        gap: 40px;
      }
      #controls {
        display: flex;
        flex-direction: column;
        width: 320px;
      }
      label {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
      }
      .input-row {
        display: flex;
        gap: 5px;
        align-items: center;
      }
      input[type="range"] {
        flex: 1;
      }
      input[type="number"] {
        width: 70px;
      }
      #outputs {
        margin-top: 20px;
        font-size: 14px;
      }
      h1 {
        margin-bottom: 0;
      }
      h2 {
        margin-top: 40px;
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body>
    <div>
      <h1>Nozzle Contour Generator</h1>
      <p><em>By Saaketh Ramoju</em></p>

      <div id="controls">
        <label
          >Nozzle Shape:
          <select id="b_or_c" onchange="updatePlot()">
            <option value="Conical">Conical</option>
            <option value="Bell">Bell</option>
          </select>
        </label>

        <!-- Example with slider + number input -->
        <label
          >Throat Radius (in):
          <div class="input-row">
            <input
              id="R_t"
              type="range"
              min="0.1"
              max="15"
              step="0.001"
              value="1"
              oninput="syncInput('R_t')"
            />
            <input
              id="R_t_num"
              type="number"
              min="0.1"
              max="15"
              step="0.001"
              value="1"
              oninput="syncSlider('R_t')"
            />
          </div>
        </label>

        <label
          >Chamber Cylindrical Length (in):
          <div class="input-row">
            <input
              id="Lc"
              type="range"
              min="1"
              max="100"
              step="0.001"
              value="10"
              oninput="syncInput('Lc')"
            />
            <input
              id="Lc_num"
              type="number"
              min="1"
              max="100"
              step="0.001"
              value="10"
              oninput="syncSlider('Lc')"
            />
          </div>
        </label>

        <label
          >Contraction Ratio:
          <div class="input-row">
            <input
              id="eps_c"
              type="range"
              min="1.5"
              max="5"
              step="0.001"
              value="3.8"
              oninput="syncInput('eps_c')"
            />
            <input
              id="eps_c_num"
              type="number"
              min="1.5"
              max="5"
              step="0.001"
              value="3.8"
              oninput="syncSlider('eps_c')"
            />
          </div>
        </label>

        <label
          >Convergence Half-Angle (째):
          <div class="input-row">
            <input
              id="theta_c"
              type="range"
              min="10"
              max="50"
              step="0.001"
              value="37.5"
              oninput="syncInput('theta_c')"
            />
            <input
              id="theta_c_num"
              type="number"
              min="10"
              max="50"
              step="0.001"
              value="37.5"
              oninput="syncSlider('theta_c')"
            />
          </div>
        </label>

        <label
          >Convergence Radius Rc/Rt:
          <div class="input-row">
            <input
              id="Rc_Rt"
              type="range"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncInput('Rc_Rt')"
            />
            <input
              id="Rc_Rt_num"
              type="number"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncSlider('Rc_Rt')"
            />
          </div>
        </label>

        <label
          >Lead-in Radius Rtc/Rt:
          <div class="input-row">
            <input
              id="Rtc_Rt"
              type="range"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncInput('Rtc_Rt')"
            />
            <input
              id="Rtc_Rt_num"
              type="number"
              min="0.1"
              max="5"
              step="0.001"
              value="1"
              oninput="syncSlider('Rtc_Rt')"
            />
          </div>
        </label>

        <label
          >Lead-out Radius Rtd/Rt:
          <div class="input-row">
            <input
              id="Rtd_Rt"
              type="range"
              min="0.1"
              max="4"
              step="0.001"
              value="0.5"
              oninput="syncInput('Rtd_Rt')"
            />
            <input
              id="Rtd_Rt_num"
              type="number"
              min="0.1"
              max="4"
              step="0.001"
              value="0.5"
              oninput="syncSlider('Rtd_Rt')"
            />
          </div>
        </label>

        <label
          >Expansion Ratio:
          <div class="input-row">
            <input
              id="eps"
              type="range"
              min="2"
              max="100"
              step="0.001"
              value="4"
              oninput="syncInput('eps')"
            />
            <input
              id="eps_num"
              type="number"
              min="2"
              max="100"
              step="0.001"
              value="4"
              oninput="syncSlider('eps')"
            />
          </div>
        </label>

        <label
          >Divergence Half-Angle (째) [Conical]:
          <div class="input-row">
            <input
              id="alpha"
              type="range"
              min="5"
              max="60"
              step="0.001"
              value="15"
              oninput="syncInput('alpha')"
            />
            <input
              id="alpha_num"
              type="number"
              min="5"
              max="60"
              step="0.001"
              value="15"
              oninput="syncSlider('alpha')"
            />
          </div>
        </label>

        <label
          >Divergence Entrance Angle (째) [Bell]:
          <div class="input-row">
            <input
              id="theta_n"
              type="range"
              min="10"
              max="80"
              step="0.001"
              value="22"
              oninput="syncInput('theta_n')"
            />
            <input
              id="theta_n_num"
              type="number"
              min="10"
              max="80"
              step="0.001"
              value="22"
              oninput="syncSlider('theta_n')"
            />
          </div>
        </label>

        <label
          >Divergence Exit Angle (째) [Bell]:
          <div class="input-row">
            <input
              id="theta_e"
              type="range"
              min="0"
              max="50"
              step="0.001"
              value="10"
              oninput="syncInput('theta_e')"
            />
            <input
              id="theta_e_num"
              type="number"
              min="0"
              max="50"
              step="0.001"
              value="10"
              oninput="syncSlider('theta_e')"
            />
          </div>
        </label>

        <label
          >Percent Bell Lf (%):
          <div class="input-row">
            <input
              id="Lf"
              type="range"
              min="60"
              max="100"
              step="0.001"
              value="80"
              oninput="syncInput('Lf')"
            />
            <input
              id="Lf_num"
              type="number"
              min="60"
              max="100"
              step="0.001"
              value="80"
              oninput="syncSlider('Lf')"
            />
          </div>
        </label>

        <button onclick="downloadCSV()">Download Contour CSV</button>
      </div>
    </div>

    <div style="flex: 1; min-width: 0">
      <div
        id="vizRow"
        style="
          display: flex;
          flex-direction: row;
          gap: 16px;
          align-items: flex-start;
          width: 100%;
        "
      >
        <!-- leave ~420px for the controls column -->
        <div id="plot" style="flex: 1; min-width: 0; height: 520px"></div>
        <div id="plot3d" style="flex: 1; min-width: 0; height: 520px"></div>
      </div>
      <h2>Calculated Values</h2>
      <div id="outputs"></div>
    </div>

    <script>
      // keep number and slider in sync
      function syncInput(id) {
        document.getElementById(id + "_num").value =
          document.getElementById(id).value;
        updatePlot();
      }
      function syncSlider(id) {
        document.getElementById(id).value = document.getElementById(
          id + "_num"
        ).value;
        updatePlot();
      }

      function getVal(id) {
        return parseFloat(document.getElementById(id).value);
      }

      function linspace(start, stop, n) {
        return Array.from(
          { length: n },
          (_, i) => start + ((stop - start) * i) / (n - 1)
        );
      }

      function updatePlot() {
        let b_or_c = document.getElementById("b_or_c").value;
        let R_t = getVal("R_t");
        let Lc = getVal("Lc");
        let eps_c = getVal("eps_c");
        let theta_c = (getVal("theta_c") * Math.PI) / 180;
        let Rc = getVal("Rc_Rt") * R_t;
        let Rtc = getVal("Rtc_Rt") * R_t;
        let Rtd = getVal("Rtd_Rt") * R_t;
        let eps = getVal("eps");
        let alpha = (getVal("alpha") * Math.PI) / 180;
        let theta_n = (getVal("theta_n") * Math.PI) / 180;
        let theta_e = (getVal("theta_e") * Math.PI) / 180;
        let Lf = getVal("Lf");

        // --- Geometry sections (same as before) ---
        let f1z = linspace(0, Lc, 200);
        let f1r = f1z.map(() => Math.sqrt(eps_c) * R_t);
        let t2 = linspace(Math.PI / 2, Math.PI / 2 - theta_c, 200);
        let f2z = t2.map((tt) => Rc * Math.cos(tt) + Lc);
        let f2r = t2.map(
          (tt) => Rc * Math.sin(tt) + Math.sqrt(eps_c) * R_t - Rc
        );
        let y3 =
          R_t * (Math.sqrt(eps_c) - 1) -
          (Rc - Rc * Math.cos(theta_c)) -
          (Rtc - Rtc * Math.cos(theta_c));
        let x3 = y3 / Math.tan(theta_c);
        let f3z = linspace(f2z[f2z.length - 1], f2z[f2z.length - 1] + x3, 200);
        let m3 = -Math.tan(theta_c);
        let f3r = f3z.map(
          (z) => m3 * (z - f2z[f2z.length - 1]) + f2r[f2r.length - 1]
        );
        let h = f3z[f3z.length - 1] + Rtc * Math.sin(theta_c);
        let k = R_t + Rtc;
        let t4 = linspace(
          Math.PI + Math.PI / 2 - theta_c,
          (3 * Math.PI) / 2,
          200
        );
        let f4z = t4.map((tt) => Rtc * Math.cos(tt) + h);
        let f4r = t4.map((tt) => Rtc * Math.sin(tt) + k);

        const zThroat = f4z[f4z.length - 1];

        let f5z, f5r;
        if (b_or_c == "Conical") {
          let t5 = linspace((3 * Math.PI) / 2, (3 * Math.PI) / 2 + alpha, 200);
          f5z = t5.map((tt) => Rtd * Math.cos(tt) + h);
          f5r = t5.map((tt) => Rtd * Math.sin(tt) + R_t + Rtd);
        } else {
          let t5 = linspace(
            (3 * Math.PI) / 2,
            (3 * Math.PI) / 2 + theta_n,
            200
          );
          f5z = t5.map((tt) => Rtd * Math.cos(tt) + h);
          f5r = t5.map((tt) => Rtd * Math.sin(tt) + R_t + Rtd);
        }

        let f6z, f6r;
        if (b_or_c == "Conical") {
          let length =
            (Math.sqrt(eps) * R_t - f5r[f5r.length - 1]) / Math.tan(alpha);
          f6z = linspace(
            f5z[f5z.length - 1],
            f5z[f5z.length - 1] + length,
            200
          );
          let m6 = Math.tan(alpha);
          f6r = f6z.map(
            (z) => m6 * (z - f5z[f5z.length - 1]) + f5r[f5r.length - 1]
          );
        } else {
          let N = [f5z[f5z.length - 1], f5r[f5r.length - 1]];
          let E = [
            (Lf / 100) *
              ((Math.sqrt(eps) * R_t - f5r[f5r.length - 1]) /
                Math.tan((15 * Math.PI) / 180)) +
              f4z[f4z.length - 1],
            Math.sqrt(eps) * R_t,
          ];
          let m1 = Math.tan(theta_n),
            m2 = Math.tan(theta_e);
          let Qx = (m1 * N[0] - N[1] - m2 * E[0] + E[1]) / (m1 - m2);
          let Qy = m1 * (Qx - N[0]) + N[1];
          let t = linspace(0, 1, 200);
          f6z = t.map(
            (tt) =>
              (1 - tt) ** 2 * N[0] + 2 * (1 - tt) * tt * Qx + tt ** 2 * E[0]
          );
          f6r = t.map(
            (tt) =>
              (1 - tt) ** 2 * N[1] + 2 * (1 - tt) * tt * Qy + tt ** 2 * E[1]
          );
        }

        let z = [].concat(
          f1z,
          f2z.slice(1),
          f3z.slice(1),
          f4z.slice(1),
          f5z.slice(1),
          f6z.slice(1)
        );
        let r = [].concat(
          f1r,
          f2r.slice(1),
          f3r.slice(1),
          f4r.slice(1),
          f5r.slice(1),
          f6r.slice(1)
        );
        window.currentContour = { z, r };

        // ---- shared extents (unique names so they won't collide) ----
        const zMinAll = Math.min(...z);
        const zMaxAll = Math.max(...z);
        const rMaxAll = Math.max(...r);

        // ===== 3D solid-of-revolution (throat-centered, y-axis orbit) =====
        const nTheta = 72;
        const theta = linspace(0, 2 * Math.PI, nTheta);
        const X = theta.map((th) => r.map((ri) => ri * Math.cos(th)));
        const Y = theta.map((th) => r.map((ri) => ri * Math.sin(th)));
        const Zgrid = theta.map(() => z.map((zi) => zi - zThroat));

        const surf = {
          type: "surface",
          x: X,
          y: Y,
          z: Zgrid,
          showscale: false,
          contours: { z: { show: false } },
          opacity: 1.0,
        };

        // frame the model around the throat; use names that don't collide
        // framing (a bit roomier)
        const zReach = Math.max(zThroat - zMinAll, zMaxAll - zThroat);
        const Rxz = 1.8 * Math.max(rMaxAll, zReach);
        const Yorbit = 1.8 * rMaxAll;

        const scene = {
          xaxis: { visible: false },
          yaxis: { visible: false },
          zaxis: { visible: false },
          aspectmode: "data",
          camera: {
            // y-axis orbit: keep y constant, spin x/z around the (throat-centered) model
            eye: { x: Rxz, y: Yorbit, z: 0 },
            up: { x: 0, y: 1, z: 0 }, // y is up; prevents 180째 flips
          },
        };

        Plotly.newPlot(
          "plot3d",
          [surf],
          { scene, margin: { l: 0, r: 0, t: 0, b: 0 } },
          { responsive: true }
        );

        // (re)start auto-rotation around y-axis through the throat
        startRotation(Rxz, Yorbit);

        const R_ch = Math.sqrt(eps_c) * R_t; // chamber barrel radius
        const yAxis = {
          title: "Radial Length (in)",
          range: [0, Math.max(3 * R_ch, 1.05 * rMaxAll)],
        };

        const xAxis = {
          title: "Axial Length (in)",
          range: [0, 1.05 * zMaxAll],
        };

        Plotly.newPlot(
          "plot",
          [
            {
              x: f1z,
              y: f1r,
              mode: "lines",
              line: { width: 3, color: "#26a9e0" }, // light blue
              name: "Chamber",
            },
            {
              x: f2z,
              y: f2r,
              mode: "lines",
              line: { width: 3, color: "#e61950" }, // red
              name: "Entrance Arc",
            },
            {
              x: f3z,
              y: f3r,
              mode: "lines",
              line: { width: 3, color: "#f7a829" }, // orange
              name: "Converging Linear",
            },
            {
              x: f4z,
              y: f4r,
              mode: "lines",
              line: { width: 3, color: "#fa791b" }, // darker orange
              name: "Throat Arc",
            },
            {
              x: f5z,
              y: f5r,
              mode: "lines",
              line: { width: 3, color: "#510c7c" }, // purple
              name: "Diverging Entrance",
            },
            {
              x: f6z,
              y: f6r,
              mode: "lines",
              line: { width: 3, color: "#092843" }, // navy blue
              name: "Nozzle",
            },
          ],
          {
            xaxis: xAxis,
            yaxis: yAxis,
            showlegend: true,
            margin: { l: 40, r: 10, t: 20, b: 40 },
          },
          { responsive: true } // <--- ADD THIS CONFIG OBJECT
        );

        // --- Calculations ---
        let At = Math.PI * R_t ** 2;
        let Ainj = Math.PI * f1r[0] ** 2;
        let Aexit = Math.PI * f6r[f6r.length - 1] ** 2;
        let Lconv = f4z[f4z.length - 1] - f2z[0];
        let Lnoz = f6z[f6z.length - 1] - f4z[f4z.length - 1];
        // Merge all chamber-to-throat contour segments
        let chamberZ = [].concat(f1z, f2z.slice(1), f3z.slice(1), f4z.slice(1));
        let chamberR = [].concat(f1r, f2r.slice(1), f3r.slice(1), f4r.slice(1));

        // Volume of revolution (disk method)
        let vol = 0;
        for (let i = 0; i < chamberZ.length - 1; i++) {
          let dx = chamberZ[i + 1] - chamberZ[i];
          vol +=
            ((Math.PI * (chamberR[i] ** 2 + chamberR[i + 1] ** 2)) / 2) * dx;
        }

        let Lstar = vol / At;

        document.getElementById("outputs").innerHTML = `
          Throat Area: ${At.toFixed(3)} in짼<br>
          Injector Area: ${Ainj.toFixed(3)} in짼<br>
          Exit Area: ${Aexit.toFixed(3)} in짼<br>
          Converging Length: ${Lconv.toFixed(3)} in<br>
          Nozzle Length: ${Lnoz.toFixed(3)} in<br>
          Chamber Volume: ${vol.toFixed(3)} in쨀<br>
          Characteristic Length (L*): ${Lstar.toFixed(3)} in
        `;
      }

      function downloadCSV() {
        if (!window.currentContour) return;
        let { z, r } = window.currentContour;
        let rows = ["Z,R"];
        for (let i = 0; i < z.length; i++) rows.push(`${z[i]},${r[i]}`);
        let blob = new Blob([rows.join("\n")], { type: "text/csv" });
        let url = URL.createObjectURL(blob);
        let a = document.createElement("a");
        a.href = url;
        a.download = "contour.csv";
        a.click();
      }

      // ---- Auto-rotation helpers (ADDED) ----
      let rotTimer = null;
      let rotAngle = 0;

      function startRotation(Rxz, Yorbit) {
        if (rotTimer) {
          clearInterval(rotTimer);
          rotTimer = null;
        }
        rotTimer = setInterval(() => {
          rotAngle += 0.02; // speed
          const eye = {
            x: Rxz * Math.cos(rotAngle),
            y: Yorbit,
            z: Rxz * Math.sin(rotAngle),
          };
          Plotly.relayout("plot3d", {
            "scene.camera.eye": eye,
            "scene.camera.up": { x: 0, y: 1, z: 0 },
          });
        }, 30);
      }

      function stopRotation() {
        if (rotTimer) {
          clearInterval(rotTimer);
          rotTimer = null;
        }
      }

      updatePlot();
    </script>
  </body>
</html>
